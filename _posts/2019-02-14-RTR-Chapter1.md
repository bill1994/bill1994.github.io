--
layout: post
title: RTR Chapter 1 memo
--
## 四个关键步骤：应用，几何处理，光栅化，像素处理。

在应用层上，CPU同时进行多线程操作。一些任务，例如碰撞检测，全局加速算法，物理模拟等都会在这里进行。到了几何计算，主要进行关于形状，投射等的几何操作，即计算这些数据之后可以知道什么将被画出，怎么被画出，在那里被画出。这一阶段主要在GPU中进行计算。光栅化处理将输入的顶点组成三角形，将所有在三角形内的像素都传递给下一个阶段。最后的像素处理阶段执行计算来决定每一个的像素是否可见还有它们的颜色。后面两个阶段都是完全在GPU中进行。

### 应用层：
这里是完全可操控的步骤。要在GPU中使用可控的操作需要计算着色器。应用层会将需要渲染的几何信息传递给下一个步骤，如：点线，三角形等最终显示的图元信息。为了提高计算速度，通过CPU多核可以多线程同步计算。在这里常见的操作就是碰撞检测。还可以接受其他键盘等输入。

### 几何操作：
这一步复制大多数的顶点及三角形操作。主要被分成四个子操作：
顶点着色--》投射--》剪切--》屏幕绘制

### 顶点着色：
主要计算顶点位置和计算需要的输出数据（法向量和纹理坐标）。通常大部分的物体的阴暗部分都是通过光照对每一个定点的位置和法向量来计算并且将会储存在顶点之中，这些颜色最后会在三角形内插值表示。
计算顶点位置还需要一系列空间坐标系：1.模型空间，模型坐标系。在经过转换后就是2.世界空间，世界坐标系。（在所有的物体经过转换后都是进入这一个空间。）然后还要经过视角转换后进入视角坐标系（摄像机坐标系）。
另一个操作是着色（shading），计算不同定点上的颜色然后保存。
投影和裁剪：将视图空间的体积转换成单位立方体（canonical view volume 标准视角空间）然后完成投影，投影有两种：正交投影和透视投影。（因为要显示在屏幕上是三维转成二维的）完成这个转换之后所有模型就是在裁剪坐标系内了。
#### 着色可选操作：
*镶嵌*，对一个球，当足够远三角形是不用那么多的，当镜头够近的时候，使用镶嵌增加三角形数量不会出现轮廓问题。
几何着色器，先于镶嵌操作，它处理不同类型的图元生成新的顶点集。因为是很简单的操作所以限制也较多。作用有产生一些粒子效果。
*流输出*，直接将顶点作为数组输出给其他使用者。

#### 裁剪：
与标准视图体积相交的点会作为取代视野之外的顶点。投射矩阵的使用就是将移动了的图元与单位立方体接触的话被裁减。除了六面裁剪，还可以定义额外的裁剪面。裁剪使用四个值的齐次坐标来投射进行裁剪。这些数值不会在透视空间里对三角形线性插值。最后就是放到NDC中。

#### 屏幕绘制：
直到这一步图形的处理都还是在三维空间中，XY坐标组成屏幕坐标系。加上z坐标系就组成窗口坐标系。所有API的像素点位置都是从左到右，上下关系的话OpenGL和DirectX有不同。

### 光栅化：
像素在图元以内的将会被这一步骤渲染。这一步骤有两个子步骤：三角形组装（或者图元组装）以及三角形遍历。光栅化也被称作扫描转换，因此就是将屏幕空间的二维顶点，带有深度值和其他着色信息的转换成屏幕上的像素。这一步也可以被认为是几何处理及像素处理的同步点，因为在这里三角形是被顶点组成最终又被送到像素处理中。

### 像素处理
分为两个子步骤：*像素着色*，*合并*。像素处理针对的是每像素或每取样的计算。
像素着色：针对单像素的操作都在这里进行，这里的着色器就是OpenGL中的片元着色器，它们包含了需要的计算数据。而纹理技术就是用在这里。
合并：顾名思义，将储存在颜色缓存中的颜色合并之后显示，也负责解决可见性。z-buffer就是带有深度值来决定是否渲染。（阴影中也有使用。）如果计算出的Z值大于存储的z值，那么颜色和z缓存都不会被更改。除了RGB，Z之外还有一个A。模板缓存（stencil buffer）就是储存一个被画下的物体，然后只描绘画下的物体里的像素信息。

接下来走一下这一个管程线，
RTR中的例子是走一遍一个华夫饼机的管程线流程,使用CAD来制作一个华夫饼机：
1.在应用层，CAD允许用户选择并移动模型的一部分，而用鼠标去移动的角度等就是由应用层去改变。或是一个相机在按照一定的路径运行展示华夫饼机时的位置和视角都是由应用层更新的。应用层提供的位置，灯光，模型的图元信息都会传输给下一个步骤：几何处理。
2.对于透视视角，我们假设应用层已经提供了投射矩阵。然后对于没一个物体也已经提供了矩阵描述他们的位置，角度等。然后到了几何处理中，顶点和法线都会根据这个矩阵转换到视角空间。之后就是根据材料和光照等因素进行着色等操作。接着是利用前面提到的投射矩阵将物体投射到一个单位立方体中。立方体之外的物体都会被裁减。然后顶点就会被绘制到窗口的屏幕中。接着数据会传递到下一步。
3.所有到了这里的图元都会被光栅化，也就是说所有在图元内的像素都会被传递到下一个步骤中。
4.到了像素处理，这里会处理每一个可见图元的像素颜色，带有照片的三角形也会被渲染上图片。可见与否由Z-buffer，还有模板测试等决定。